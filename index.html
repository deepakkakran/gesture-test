<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Controlled 3D Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: sans-serif;
        }
        canvas {
            display: block;
        }
        /* Hide the webcam feed explicitly */
        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffcc;
            font-size: 1.2rem;
            pointer-events: none;
            text-align: center;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initializing GPU & Camera...<br>Please allow camera access.</div>
    <video id="input_video" playsinline></video>
    
    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 4000; // Optimized for mobile (keep < 8000 for older phones)
        const PARTICLE_SIZE = 0.8;
        const CAM_FOV = 75;
        
        // --- GLOBALS ---
        let scene, camera, renderer, particles, particleGeo;
        let positions, velocities, originalPositions;
        let mouse = new THREE.Vector2(9999, 9999); // Start off-screen
        let target = new THREE.Vector3();
        let isHandDetected = false;
        
        const videoElement = document.getElementById('input_video');
        const loadingElement = document.getElementById('loading');

        // --- 1. THREE.JS SETUP (GPU RENDERING) ---
        function initThree() {
            scene = new THREE.Scene();
            // Add subtle fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(CAM_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
            document.body.appendChild(renderer.domElement);

            createParticles();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function createParticles() {
            particleGeo = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            originalPositions = new Float32Array(PARTICLE_COUNT * 3);

            const spread = 80;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = (Math.random() - 0.5) * spread;
                const y = (Math.random() - 0.5) * spread;
                const z = (Math.random() - 0.5) * spread;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                velocities[i * 3] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = 0;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            // Create a custom texture or use a simple point
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            const material = new THREE.PointsMaterial({
                color: 0x00aaff,
                size: PARTICLE_SIZE,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(particleGeo, material);
            scene.add(particles);
        }

        // --- 2. MEDIAPIPE HAND TRACKING SETUP ---
        function onResults(results) {
            loadingElement.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Track the palm center (Landmark 9) or Index Finger (Landmark 8)
                // Coordinates are normalized [0,1]. We map them to screen space (NDC).
                // x is inverted because webcam is mirrored.
                const x = (1 - landmarks[9].x) * 2 - 1; 
                const y = -(landmarks[9].y * 2 - 1); 
                
                // Smooth interpolation for the target vector to reduce jitter
                target.x += (x * 40 - target.x) * 0.2; 
                target.y += (y * 40 - target.y) * 0.2;
                target.z = 0; // Hand stays roughly in the middle plane
                
                // Change color on interaction
                particles.material.color.setHex(0x00ffcc);
            } else {
                isHandDetected = false;
                particles.material.color.setHex(0x0055ff);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // 0 is fastest, 1 is balanced
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640, // Lower resolution for processing speed
            height: 480
        });

        cameraUtils.start();

        // --- 3. ANIMATION LOOP (PHYSICS) ---
        function animate() {
            requestAnimationFrame(animate);

            const posArray = particleGeo.attributes.position.array;
            
            // Time factor for swirling
            const time = Date.now() * 0.001;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let px = posArray[ix];
                let py = posArray[iy];
                let pz = posArray[iz];

                // Base State: Gentle Sine Wave Floating
                let tx = originalPositions[ix] + Math.sin(time + originalPositions[iy]) * 2;
                let ty = originalPositions[iy] + Math.cos(time + originalPositions[ix]) * 2;
                let tz = originalPositions[iz];

                // Hand Interaction Logic
                if (isHandDetected) {
                    // Calculate distance to hand
                    const dx = target.x - px;
                    const dy = target.y - py;
                    const dz = target.z - pz;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq);

                    // ATTRACTION Force (swirl towards hand)
                    if (dist < 40) {
                        const force = (40 - dist) / 40; 
                        
                        // Move towards hand
                        velocities[ix] += dx * 0.005 * force;
                        velocities[iy] += dy * 0.005 * force;
                        velocities[iz] += dz * 0.005 * force;

                        // Add Swirl/Vortex effect
                        velocities[ix] += -dy * 0.02; 
                        velocities[iy] += dx * 0.02;
                    }
                } 

                // Return to original if no hand or far away
                const homeDx = tx - px;
                const homeDy = ty - py;
                const homeDz = tz - pz;

                velocities[ix] += homeDx * 0.02;
                velocities[iy] += homeDy * 0.02;
                velocities[iz] += homeDz * 0.02;

                // Damping (Friction)
                velocities[ix] *= 0.92;
                velocities[iy] *= 0.92;
                velocities[iz] *= 0.92;

                // Update Position
                posArray[ix] += velocities[ix];
                posArray[iy] += velocities[iy];
                posArray[iz] += velocities[iz];
            }

            particleGeo.attributes.position.needsUpdate = true;
            
            // Slight Scene Rotation
            scene.rotation.y += 0.002;
            scene.rotation.x += 0.001;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start Three.js
        initThree();
    </script>
</body>
</html>
