<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AR Hand Force Field – GPU Particles</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: black;
}
video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  z-index: 0;
}
canvas {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1;
}
#hud {
  position: fixed;
  top: 10px;
  left: 10px;
  color: #0ff;
  font-family: monospace;
  z-index: 2;
}
</style>
</head>

<body>

<div id="hud">Initializing…</div>
<video id="video" autoplay playsinline muted></video>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =============================
   HUD
============================= */
const hud = msg => document.getElementById("hud").textContent = msg;

/* =============================
   CAMERA BACKGROUND (AR)
============================= */
const video = document.getElementById("video");

/* =============================
   THREE SETUP
============================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 150;

const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* =============================
   GPU PARTICLES
============================= */
const COUNT = innerWidth < 768 ? 20000 : 50000;

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const velocities = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT * 3; i += 3) {
  positions[i]     = (Math.random() - 0.5) * 300;
  positions[i + 1] = (Math.random() - 0.5) * 300;
  positions[i + 2] = (Math.random() - 0.5) * 300;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("velocity", new THREE.BufferAttribute(velocities, 3));

const material = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  uniforms: {
    uTime: { value: 0 },
    uHand: { value: new THREE.Vector3() },
    uForce: { value: new THREE.Vector3() }
  },
  vertexShader: `
    attribute vec3 velocity;
    uniform float uTime;
    uniform vec3 uHand;
    uniform vec3 uForce;
    varying float vDist;

    void main() {
      vec3 pos = position;

      vec3 dir = pos - uHand;
      float dist = length(dir) + 0.001;
      dir = normalize(dir);

      // Force field
      vec3 force = -dir * 200.0 / dist;
      force += uForce * 15.0;

      pos += velocity + force * 0.01;

      vDist = dist;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = 2.5;
    }
  `,
  fragmentShader: `
    varying float vDist;
    void main() {
      float alpha = smoothstep(200.0, 0.0, vDist);
      gl_FragColor = vec4(0.0, 1.0, 1.0, alpha);
    }
  `
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* =============================
   HAND TRACKING
============================= */
let handPos = new THREE.Vector3();
let lastHand = new THREE.Vector3();
let handForce = new THREE.Vector3();

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (!res.multiHandLandmarks.length) return;

  hud("Hand detected");

  const p = res.multiHandLandmarks[0][9];
  const x = (p.x - 0.5) * 400;
  const y = (0.5 - p.y) * 400;
  const z = -p.z * 400;

  handPos.set(x, y, z);
  handForce.subVectors(handPos, lastHand);
  lastHand.copy(handPos);

  material.uniforms.uHand.value.copy(handPos);
  material.uniforms.uForce.value.copy(handForce);
});

/* =============================
   CAMERA START
============================= */
new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
}).start().then(() => hud("AR + GPU running"));

/* =============================
   LOOP
============================= */
function animate(t) {
  material.uniforms.uTime.value = t * 0.001;
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* =============================
   RESIZE
============================= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
